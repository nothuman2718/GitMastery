<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Mastering Git - GitMastery</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Introduction", url: "#_top", children: [
              {title: "What are version control systems?", url: "#what_are_version_control_systems" },
              {title: "What is git?", url: "#what_is_git" },
              {title: "What is GitHub?", url: "#what_is_github" },
              {title: "Installing Git", url: "#installing_git" },
          ]},
          {title: "Basics", url: "#basics", children: [
              {title: "Configuring git", url: "#configuring_git" },
          ]},
          {title: "Git Workflow", url: "#git_workflow", children: [
              {title: "Creating Snapshots", url: "#creating_snapshots" },
              {title: "Creating A Repository", url: "#creating_a_repository" },
              {title: "Staging", url: "#staging" },
              {title: "Committing", url: "#committing" },
              {title: "Best Practice while committing", url: "#best_practice_while_committing" },
              {title: "Unstaging files", url: "#unstaging_files" },
              {title: "gitignore", url: "#gitignore" },
              {title: "View Local Changes", url: "#view_local_changes" },
          ]},
          {title: "Viewing a commit", url: "#viewing_a_commit", children: [
          ]},
          {title: "Browsing History", url: "#browsing_history", children: [
              {title: "Viewing History", url: "#viewing_history" },
              {title: "Filtering History", url: "#filtering_history" },
              {title: "Find the contributors", url: "#find_the_contributors" },
              {title: "Restore deleted file", url: "#restore_deleted_file" },
              {title: "Aliases", url: "#aliases" },
              {title: "Moving to another Commit", url: "#moving_to_another_commit" },
          ]},
          {title: "Branching", url: "#branching", children: [
              {title: "Branch Management", url: "#branch_management" },
              {title: "Merging", url: "#merging" },
              {title: "Fast Forward Merge", url: "#fast_forward_merge" },
              {title: "Three Way Merge", url: "#three_way_merge" },
              {title: "Fast Forward Merge", url: "#fast_forward_merge_1" },
              {title: "Three way merge", url: "#three_way_merge_1" },
              {title: "Merge Conflicts", url: "#merge_conflicts" },
              {title: "Undoing a faulty merge.", url: "#undoing_a_faulty_merge" },
              {title: "Squash Merging", url: "#squash_merging" },
              {title: "Rebasing", url: "#rebasing" },
          ]},
          {title: "Collaboration", url: "#collaboration", children: [
              {title: "Centralized Workflow", url: "#centralized_workflow" },
              {title: "Integration Workflow", url: "#integration_workflow" },
              {title: "Fetching", url: "#fetching" },
              {title: "Pulling", url: "#pulling" },
              {title: "Pushing", url: "#pushing" },
              {title: "Storing Credentials", url: "#storing_credentials" },
              {title: "Sharing Tags", url: "#sharing_tags" },
              {title: "Releases", url: "#releases" },
              {title: "Sharing branches", url: "#sharing_branches" },
              {title: "Pull Requests", url: "#pull_requests" },
              {title: "Contributing to open source", url: "#contributing_to_open_source" },
          ]},
          {title: "Rewriting History", url: "#rewriting_history", children: [
              {title: "The Main Rule For Rewriting History.", url: "#the_main_rule_for_rewriting_history" },
              {title: "Undoing Commits", url: "#undoing_commits" },
              {title: "Reverting Commits", url: "#reverting_commits" },
              {title: "Recovering Lost Commits", url: "#recovering_lost_commits" },
              {title: "Amending The Last Commit", url: "#amending_the_last_commit" },
          ]},
          {title: "Amending an earlier commit", url: "#amending_an_earlier_commit", children: [
              {title: "Dropping Commits", url: "#dropping_commits" },
              {title: "Reword Commit Messages", url: "#reword_commit_messages" },
              {title: "Reordering Commits", url: "#reordering_commits" },
              {title: "Squashing Commits", url: "#squashing_commits" },
              {title: "Splitting A Commit", url: "#splitting_a_commit" },
          ]},
          {title: "Advanced", url: "#advanced", children: [
              {title: "ls-tree", url: "#ls-tree" },
              {title: "Formatting The Log", url: "#formatting_the_log" },
              {title: "Bisect Command", url: "#bisect_command" },
              {title: "Tagging", url: "#tagging" },
              {title: "Stashing", url: "#stashing" },
              {title: "Worktrees", url: "#worktrees" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script>
      <script src="../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../The90%25Stuff/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../The90%25Stuff/" class="btn btn-xs btn-link">
        The 90% Stuff
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href=".." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href=".." class="btn btn-xs btn-link">
        Home
      </a>
    </div>
    
  </div>

    

    <h1 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h1>
<h2 id="what_are_version_control_systems">What are version control systems?<a class="headerlink" href="#what_are_version_control_systems" title="Permanent link">&para;</a></h2>
<p>Version control systems record changes made to our code in a special database called repository. We can see the project history, who made the changes, and when and why. If something terrible happens, we can quickly return to our previous state. Without a version control system, we have to constantly store copies of projects, which is not at all scalable, and contribution also becomes too difficult. Version Control systems fall into two categories.</p>
<h3 id="cvcs">CVCS<a class="headerlink" href="#cvcs" title="Permanent link">&para;</a></h3>
<p>In Centralised Version Control Systems(CVCSs), all team members connect to a central repository to get changes. Subversion and Microsoft Team Foundation Server are examples of these. The disadvantage of CVCS is its single point of failure. If the server goes offline, we cannot create snapshots or get new changes until the server comes back online. For many years, this has been the standard for version control.</p>
<h3 id="dvcs">DVCS<a class="headerlink" href="#dvcs" title="Permanent link">&para;</a></h3>
<p>This is where Distributed Version Control Systems (DVCSs) step in.
In Distributed Version Control Systems(DVCS), everyone has a copy of the repository with history on their machine locally. So we can save snapshots of our work locally and synchronize them with others afterwards. Git and Mercurial are examples of these. This allows you to set up several types of workflows that aren’t possible in centralized systems, such as hierarchical models.</p>
<h2 id="what_is_git">What is git?<a class="headerlink" href="#what_is_git" title="Permanent link">&para;</a></h2>
<p>Out of all these version control systems, Git is the most popular one. Because it is free, open-source, fast and scalable, Git stores and thinks about information differently, and understanding these differences will help you avoid becoming confused while using it. It stores snapshots, not differences. I will say this a couple more times, so remember this. Git doesn't store differences. It stores snapshots. This is a fundamental concept to understand. When you commit, Git keeps a snapshot of what all your files look like at that moment and stores a reference to that snapshot. If the file hasn't changed, Git doesn't keep it again; it is just a link to the previous identical file stored. This is why Git is so fast and efficient. It doesn't store duplicate content. Git is also very good at branching and merging. It is straightforward to create branches and merge them; only a bit of common sense is required. This is why Git is very popular among developers.</p>
<p>We can use the git cli which is fast and easiest for most of the time. But almost all editors support basic git features. There are also graphical user interfaces specifically made to use git. But these GUI tools have some limitations. GitKraken is one of the most popular ones.</p>
<h2 id="what_is_github">What is GitHub?<a class="headerlink" href="#what_is_github" title="Permanent link">&para;</a></h2>
<p>GitHub is a popular git hosting platform in the world. Which makes collaboration far more easy. A large percentage of git repositories are hosted on GitHub, and many open-source projects use it for Git hosting, issue tracking, code review, and other things. It is also the largest source code host in the world, with over 100 million repositories. GitHub is the most popular platform for open-source projects. It has a lot of features that make it easy to work with other people. You can also use GitHub to host your own projects, and it is a great way to show off your coding skills to the world. It is also a great way to contribute to open-source projects.</p>
<h2 id="installing_git">Installing Git<a class="headerlink" href="#installing_git" title="Permanent link">&para;</a></h2>
<h3 id="installing_on_windows">Installing on Windows<a class="headerlink" href="#installing_on_windows" title="Permanent link">&para;</a></h3>
<p>Go to the <a href="https://git-scm.com/">official website</a> and download the latest version of git. After downloading, run the installer and follow the instructions. You can verify the installation by running the following command.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>--version
</code></pre></div>
<h3 id="installing_on_mac">Installing on Mac<a class="headerlink" href="#installing_on_mac" title="Permanent link">&para;</a></h3>
<p>There are two ways to install git on mac. One is to download the latest version from the official website. The second one is to use the homebrew package manager. Homebrew is the most popular package manager for mac. If you don't have it, you can install it by running the following command.</p>
<div class="highlight"><pre><span></span><code>/bin/bash<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>curl<span class="w"> </span>-fsSL<span class="w"> </span>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span class="k">)</span><span class="s2">&quot;</span>
</code></pre></div>
<p>After installing homebrew, you can install git by running the following command.</p>
<div class="highlight"><pre><span></span><code>brew<span class="w"> </span>install<span class="w"> </span>git
</code></pre></div>
<p>After installing, you can verify the installation by running the following command.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>--version
</code></pre></div>
<h1 id="basics">Basics<a class="headerlink" href="#basics" title="Permanent link">&para;</a></h1>
<h2 id="configuring_git">Configuring git<a class="headerlink" href="#configuring_git" title="Permanent link">&para;</a></h2>
<p>The first time we use git we have to specify a few configuration settings.</p>
<p>To configure name</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>user.name<span class="w"> </span><span class="s2">&quot;vlm lokesh&quot;</span>
</code></pre></div>
<p>To configure email ( In email there is no space so double quotes are optional )</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>user.email<span class="w"> </span>nothuman2.718@gmail.com
</code></pre></div>
<p>To configure the editor ( If We don't set this by default in mac it takes vim in other OS it takes system default editor ). This command is for vscode. Meaning of the --wait flag is thread waits until we close the editor.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>core.editor<span class="w"> </span><span class="s2">&quot;code --wait&quot;</span>
</code></pre></div>
<p>Use this to open global config file</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>-e
</code></pre></div>
<p>To configure line ending ( In windows end of the line is marked with two special characters \r =&gt; carriage return and \n =&gt; line feed. But in mac and linux the end of line is \n =&gt; line feed only ). So when we are working with a team, we should configure this properly.</p>
<p>For windows (automatically changes line feed when pulling and pushing)</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>core.autocrlf<span class="w"> </span><span class="nb">true</span>
</code></pre></div>
<p>For Linux (You should only change the line feed when storing data in a repository, like input to the repository. If your file has CRLF, it should be converted to LF. Sometimes, it may happen when you get a file from a Windows user. The Unix systems will not throw any error even if you have CRLF in your file. They can handle both. But when you push the file to the repository, it should be converted to LF)</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>core.autocrlf<span class="w"> </span>input
</code></pre></div>
<h1 id="git_workflow">Git Workflow<a class="headerlink" href="#git_workflow" title="Permanent link">&para;</a></h1>
<h2 id="creating_snapshots">Creating Snapshots<a class="headerlink" href="#creating_snapshots" title="Permanent link">&para;</a></h2>
<h2 id="creating_a_repository">Creating A Repository<a class="headerlink" href="#creating_a_repository" title="Permanent link">&para;</a></h2>
<p>Before starting a project. When you create a folder it's better to initialize git at that moment itself.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>init
</code></pre></div>
<p>After you will see a message that an empty git repository is initialized. If you want to check whether git is initialized you can do this command ( To see hidden files, by default .git directory is hidden, we are not supposed to modify it )</p>
<div class="highlight"><pre><span></span><code>ls<span class="w"> </span>-a
</code></pre></div>
<p>You can see .git directory you can open that by using.</p>
<div class="highlight"><pre><span></span><code>open<span class="w"> </span>.git
</code></pre></div>
<p>If you are using git, that doesn't mean you should understand all those details. Those are just implementation details. But understanding these helps you get a strong foundation. If we remove this directory, you will lose your project history.</p>
<p>Very Very dangerous command. Do only when you know what you are doing.</p>
<div class="highlight"><pre><span></span><code>rm<span class="w"> </span>-rf<span class="w"> </span>.git
</code></pre></div>
<p><img alt="workflow" src="../img/workflow.png" /></p>
<ul>
<li>We modify one or more files as we work on different tasks. We commit the changes when our project reaches a state we want to record.</li>
<li>Commit is like taking a snapshot of the current scenario.</li>
<li>Git, unlike other VCS, introduces a crucial element in our workflow- the staging area or index. This intermediary space is where we add our modified changes for review before committing them. It's a vital part of ensuring we commit to the right changes.</li>
<li>The staging area is our tool for recording work before committing. It allows us to commit changes in stages. For instance, if we want to commit some changes separately after reviewing the staging area, we can easily un-stage them and commit the changes excluding this. This approach promotes a more organized and manageable development process.</li>
<li>Remember one thing: We should always properly follow the separation of concerns and commit the message according to each concern.</li>
<li>A fundamental principle in git usage is to maintain a useful history. We make commits as we fix bugs, implement new features, and refactor code. Each commit should serve as a clear and concise explanation of the project's state. This practice helps us track changes and aids in collaboration and troubleshooting.</li>
<li>Many people think that once we commit, the staging area becomes empty. But that's not true. This is why most people feel git is confusing.</li>
<li>Even though we are deleting some files in the working directory that were staged before, we still use git add. To un-stage a file that has been deleted in the active directory.</li>
<li>Each commit contains the unique identifier generated by git, a commit message, by whom and when, and a complete snapshot of the project when it was created. Each commit stores the complete data at that particular time, unlike other VCS.</li>
<li>Git is very efficient in storing data. It compresses files and doesn't store any duplicate content. Remember this again: "SNAPSHOTS NOT, DIFFERENCES".</li>
</ul>
<p><img alt="workflow2" src="../img/workflow2.png" /></p>
<h2 id="staging">Staging<a class="headerlink" href="#staging" title="Permanent link">&para;</a></h2>
<p>You can run this command to get status of working directory and staging area. Index is the old term for staging area.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>status
</code></pre></div>
<p>You can use the -s flag to get a short status.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>status<span class="w"> </span>-s
</code></pre></div>
<p>You can see this example</p>
<p><img alt="ShortStatus" src="../img/ShortStatus.png" /></p>
<p>Here is how it works. The leftmost column represents the index or staging area and beside column represents the working directory. From the image you can see that</p>
<ul>
<li>file1.txt is modified and also staged(M_)</li>
<li>file2.txt modified and staged after again modified in working directory(MM)</li>
<li>file3.txt is untracked in both the staging area and working directory(??)</li>
</ul>
<p>You can see untracked files in red colour. You may have many files in your project, but git will not track them unless you specify. Using this command, you can track them.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>add<span class="w"> </span>file1.txt<span class="w"> </span>file2.txt
</code></pre></div>
<p>If you want to add all files in one go. Use this command it will add recursively. You can use patterns to add files.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>add<span class="w"> </span>.
</code></pre></div>
<p>You can run the status command after adding them; you can see that all those files are now tracked and changed to green colour. If you modified some files in the working directory that were already staged, you should again add them to the staging area to make changes.</p>
<h2 id="committing">Committing<a class="headerlink" href="#committing" title="Permanent link">&para;</a></h2>
<p>If you use the -m flag, you can give a short message of what that commit is about without opening an editor. Sometimes, if the short message isn't enough, then you can do <strong>git commit</strong>, and then the default editor gets, asking you to enter a commit message. Most of the time, we use the -m flag.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Generic message&quot;</span>
</code></pre></div>
<p>After committing your changes you can see basic statistics of what has been committed.</p>
<h2 id="best_practice_while_committing">Best Practice while committing<a class="headerlink" href="#best_practice_while_committing" title="Permanent link">&para;</a></h2>
<p>Your commits should be a manageable size. We don't want to make a commit every time we change a file; that's just useless. The whole point of committing is to keep checkpoints as we go. So if we screw up, we can always go back and recover the code. As you feel like you have reached a state, you want to record the change and then make a commit. Each commit should also represent a logically different chain set. So, keep things from mixing up. In terms of wording, most people prefer to use the present tense. It is not a must-follow rule. But whatever you use, use consistently along with your team members.</p>
<p>We can skip the staging area and directly commit. But do only when you are confident about what you are doing. If you are not sure, don't do it because that's why the staging area is there. The key takeaway is that you can't track newly added files. To follow them, you need first to stage them.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>commit<span class="w"> </span>-am<span class="w"> </span><span class="s2">&quot;Do only when you know what you are doing&quot;</span>
</code></pre></div>
<p>To know what files are there in the staging area. Use this command</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>ls-files
</code></pre></div>
<p>To remove a file. We have to remove it from both the working directory and staging area. Git gives a command that does both operations in one go.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>rm<span class="w"> </span>file1.txt
</code></pre></div>
<p>To rename files in unix we use <strong>mv</strong> command. There is so much in this command, usually when we want to rename we use this</p>
<div class="highlight"><pre><span></span><code>mv<span class="w"> </span>file1.txt<span class="w"> </span>newname
</code></pre></div>
<p>But when you use the above command in a project tracked by git, git takes this command differently: deletion of file1.txt, which is <strong>an unstaged change</strong> and an addition of an <strong>untracked file</strong> newname. So, when you try to change the name of a folder, the entire content gets deleted, and a new folder with the same content gets added. This is very bad practice. I have recently made this type of change, which changed the quality of my contributions.</p>
<p><img alt="RenameBug" src="../img/RenameBug.png" /></p>
<p>So when you want to rename a file which is completely tracked by git. Use this command provided by git</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>mv<span class="w"> </span>newname<span class="w"> </span>file1.txt
</code></pre></div>
<h2 id="unstaging_files">Unstaging files<a class="headerlink" href="#unstaging_files" title="Permanent link">&para;</a></h2>
<p>We should always review the stuff that you have in the staging area before making commit. After reviewing, if we find that some changes should not be part of this commit, we need to upstage those changes. So, we need to undo the add operation.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># We can also use reset command.</span>
git<span class="w"> </span>restore<span class="w"> </span>--staged<span class="w"> </span>file1.txt
</code></pre></div>
<p>You need to understand how the restore command works. The restore command takes the copy from the following environment. So, for the staging environment, what is the following environment? It is the last commit we have in the repository. So, git takes the copy of this snapshot from the previous commit and modifies this staging area. Newly added files become untracked files.</p>
<h3 id="discarding_local_changes">Discarding Local Changes<a class="headerlink" href="#discarding_local_changes" title="Permanent link">&para;</a></h3>
<p>We can discard the local changes using restore command</p>
<div class="highlight"><pre><span></span><code><span class="c1"># When we execute this command. Git copies the content from the next environment. What is the next environment here? It&#39;s the staging area.</span>
git<span class="w"> </span>restore<span class="w"> </span>file1.txt


<span class="c1"># Undo all changes. Remember this command is dangerous. It will remove all the changes in the working directory. So, use this command only when you are sure.</span>
git<span class="w"> </span>restore<span class="w"> </span>.
</code></pre></div>
<p>You can observe a thing like that. Git cannot remove untracked files using the restore command. For that you need to use</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Remove all untracked files. Git gives a warning. Because this is a dangerous operation. So we need to use -fd to force remove all untracked files in whole directory</span>
git<span class="w"> </span>clean<span class="w"> </span>-fd
</code></pre></div>
<h2 id="gitignore">gitignore<a class="headerlink" href="#gitignore" title="Permanent link">&para;</a></h2>
<p>In almost every project, we should say git to ignore specific files and directories. We don't want to include log files, binary files, executable files, node_modules, etc. Adding these files will increase the repository size without providing any values. So, to prevent this, we have to create a file called .gitignore. We can include as many files and directories as we want; this only works if you haven't included a file or directory in your repository. In other words, if you accidentally added a folder into the repository and later formed the folder in gitignore, that doesn't work. So if that happens, remove the file from the staging area, include it in .gitignore, and commit. From this point on, git will not track that folder.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Ignore all .k extension files</span>
<span class="se">\*</span>.k

<span class="c1"># But do track all lib.k, even though you are ignoring all .k files above</span>
!lib.k

<span class="c1"># Only ignore TOP file in the current directory, not subdir/TOP</span>
/TOP

<span class="c1"># Ignore all .DS_Store in any directory</span>
.DS_Store/

<span class="c1"># Ignore all doc/.txt files but not doc/subdir/.txt files</span>

doc/*.txt

<span class="c1"># Ignore all doc/.txt files even if they are in the subdirectories of doc directory.</span>
doc/**/*.txt
</code></pre></div>
<p>For small projects generally we have a single .gitignore file. But as the project scales up there will be multiple .gitignore files in subdirectories. The rules in this nested .gitignore applies to its subdirectories.</p>
<p>If you have any queries on how to use .gitignore. Click this <a href="https://github.com/github/gitignore">link</a>. You can also search for git templates for almost all programming languages. There are almost 200+ gitignore templates for many types of projects.</p>
<h2 id="view_local_changes">View Local Changes<a class="headerlink" href="#view_local_changes" title="Permanent link">&para;</a></h2>
<p>Before committing changes, we need to review our code. Because we want to avoid committing bad code to our repository, as a best practice, always review your code in the staging area before committing. The git status command only shows the files that have been affected. To see what exactly is changed, we use the git diff command.</p>
<p>To see what exactly changed compared to the previous commit.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>diff<span class="w"> </span>--staged

<span class="c1"># To see what words are changed</span>
git<span class="w"> </span>diff<span class="w"> </span>--word-diff
</code></pre></div>
<p><img alt="GitDiff" src="../img/GitDiff.png" /></p>
<p>From above image. Here is the breakdown</p>
<h4 id="in_file1txt">In file1.txt<a class="headerlink" href="#in_file1txt" title="Permanent link">&para;</a></h4>
<p>a/file1.txt represents older file from last commit
b/file1.txt is the current file in the staging area.
Changes in the older file are shown as --a/file1.txt and changes in staged file are shown as ++b/file1.txt.
@@ -1,2 +1,3 @@ Represents total line in older file(-1) is 2 and total lines in newer file(+1) is 3. And down you can see the total content of the file after changes.</p>
<h4 id="in_file3txt">In file3.txt<a class="headerlink" href="#in_file3txt" title="Permanent link">&para;</a></h4>
<p>You can see --- /dev/null this says that file3.txt is not there in the older commit.</p>
<p>If we want to see the changes between working directory and staging area we can use diff command without any flags(unstaged changes)</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>diff
</code></pre></div>
<p>Above command will not show untracked files while showing diff between staging area and working directory.</p>
<p>Quite frankly. We cannot use the terminal to use the diff command. We need to use visual tools for better experience.</p>
<h1 id="viewing_a_commit">Viewing a commit<a class="headerlink" href="#viewing_a_commit" title="Permanent link">&para;</a></h1>
<p>Use this command to get the history. Sorted from the latest to top.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#For seeing total and detailed log</span>
git<span class="w"> </span>log
</code></pre></div>
<p>Each commit has a unique identifier, which is a 40-character unique hexadecimal string. Next to that, we can see branches. For each commit, we can see the author's email, the Date and time when the commit was created and a one-line commit message.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#For seeing a short summary of the commits.</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline

<span class="c1">#In reverse order. Sorted from oldest to newest</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--reverse
</code></pre></div>
<p>For viewing what exactly is changed in commit we use show command</p>
<div class="highlight"><pre><span></span><code><span class="c1">#unique identifier for some commit is 3b0003b</span>
git<span class="w"> </span>show<span class="w"> </span>3b0003b


<span class="c1">#we can also type unique identifier partially as long as we don&#39;t have other commits starting with that</span>
git<span class="w"> </span>show<span class="w"> </span>3b00


<span class="c1">#We can also use the ref HEAD pointer and specify how many steps we wanna go back. Shows one commit before HEAD.</span>
git<span class="w"> </span>show<span class="w"> </span>HEAD~1
</code></pre></div>
<p>All above commands show the changes in multiple files. But if we want to see a particular file in a particular commit we can use above commands and mention the path</p>
<div class="highlight"><pre><span></span><code><span class="c1"># To see contents of .gitignore. Let path .gitignore is subdir/.gitignore</span>
git<span class="w"> </span>show<span class="w"> </span>3b0003b~2:subdir/.gitignore
</code></pre></div>
<h1 id="browsing_history">Browsing History<a class="headerlink" href="#browsing_history" title="Permanent link">&para;</a></h1>
<p>After creating several commits, or if you have cloned a repository with an existing commit history, you'll probably want to look back to see what has happened. The most basic and powerful tool for doing this is the git log command.
Most of the time, you use this when doing projects sparingly. But this is a must skill if you want to contribute to open source or maintain a project. Overall, knowing this in-depth is a better idea.</p>
<h2 id="viewing_history">Viewing History<a class="headerlink" href="#viewing_history" title="Permanent link">&para;</a></h2>
<p>We can use the log command to get the history. By default all commits are sorted from newest to oldest.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Get all commits in detail</span>
git<span class="w"> </span>log


<span class="c1">#Gives the summary of all these commits</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline
</code></pre></div>
<p>If we want to see the actual changes in each commit use --patch flag</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--patch
</code></pre></div>
<h2 id="filtering_history">Filtering History<a class="headerlink" href="#filtering_history" title="Permanent link">&para;</a></h2>
<p>In real-world projects, we often have thousands of commits depending on the age of the repository. We only want to see some of the commits. So, filtering the commits is important. We can filter by author, by date, by commit message, and by content.</p>
<p>If we want to see the last 10 commits. Use this command</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Shows the last 10 commits</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>-10
</code></pre></div>
<p>Filter by author.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--author<span class="o">=</span>nothuman2718
</code></pre></div>
<p>Filter by time. We can use before and after, We can also specify relative units like yesterday.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Shows all commits after Feb 20</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--after<span class="o">=</span><span class="s2">&quot;2024-02-20&quot;</span>
</code></pre></div>
<p>Filter by commit messages.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#note this command is case sensitive</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--grep<span class="o">=</span><span class="s2">&quot;Word&quot;</span>
</code></pre></div>
<p>Filter by content.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#gives all the commits that added or deleted &quot;keyword&quot; this is also case sensitive</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>-S<span class="s2">&quot;key word&quot;</span>
</code></pre></div>
<p>Filter by range</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Gives all commits from hash1+1 commit to hash2</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>hash1..hash2
</code></pre></div>
<p>All the commits that touch a particular file. Simply add the filename at the end</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Shows all the commits that have touched file1.txt, the filename should be last argument</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>file1.txt

<span class="c1">#Same command as above, but if you specified multiple flags, then you should separate the filename</span>
git<span class="w"> </span>log<span class="w"> </span>--<span class="w"> </span>file1.txt
</code></pre></div>
<p>Beauty of these commands is, you can use them together and that makes the filtering easy.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Lists all the commits actual changes, committed by nothuman2718 after Jan 1st 2024, having Authentication keyword in the commit message, and have modified or deleted Filter word in the content.</span>
git<span class="w"> </span>log<span class="w"> </span>--author<span class="o">=</span>nothuman2718<span class="w"> </span>--after<span class="o">=</span><span class="m">2024</span>-01-01<span class="w"> </span>--grep<span class="o">=</span><span class="s2">&quot;Authentication&quot;</span><span class="w"> </span>-S<span class="s2">&quot;Filter word&quot;</span><span class="w"> </span>--patch
</code></pre></div>
<h2 id="find_the_contributors">Find the contributors<a class="headerlink" href="#find_the_contributors" title="Permanent link">&para;</a></h2>
<p>Sometimes we need to find all the people who have contributed to the project.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Returns the all contributors, how many contributions they have made and there commit messages</span>
git<span class="w"> </span>shortlog

<span class="c1">#Returns all the authors sorted based on their no.of commit messages, and their email in summary</span>
git<span class="w"> </span>shortlog<span class="w"> </span>-n<span class="w"> </span>-e<span class="w"> </span>-s
</code></pre></div>
<h2 id="restore_deleted_file">Restore deleted file<a class="headerlink" href="#restore_deleted_file" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">#First find the file.</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--<span class="w"> </span>deleted.txt
</code></pre></div>
<p>Now after getting a log. Go to its parent and only restore this file in working directory</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Just add this file to the working area. We are not in a detached HEAD state. You will see what that is in future.</span>
git<span class="w"> </span>checkout<span class="w"> </span>parenthash<span class="w"> </span>deleted.txt

<span class="c1">#After commit this changes, so that file is restored</span>
</code></pre></div>
<p>In the real world, each file will be changed by different contributors, So for knowing the author of each line we use the blame tool.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># shows every line and the author.</span>
git<span class="w"> </span>blame<span class="w"> </span>file1.txt

<span class="c1">#If there is a large file, then we should specify the range of lines</span>
git<span class="w"> </span>blame<span class="w"> </span>-L<span class="w"> </span><span class="m">1</span><span class="w"> </span>,3<span class="w"> </span>file1.txt

<span class="c1">#ignore whitespace</span>
git<span class="w"> </span>blame<span class="w"> </span>-w<span class="w"> </span>file1.txt

<span class="c1">#ignore whitespace and detect lines moved</span>
git<span class="w"> </span>blame<span class="w"> </span>-w<span class="w"> </span>-C<span class="w"> </span>file1.txt
</code></pre></div>
<h2 id="aliases">Aliases<a class="headerlink" href="#aliases" title="Permanent link">&para;</a></h2>
<p>Git doesn’t automatically infer your command if you type it in partially. If you don’t want to type the entire text of each Git command, you can easily set up an alias for each command using Git config. Here are a couple of examples you may want to set up:
In git, we can easily set aliases for frequently used commands. So we can skip typing in long form. Aliases increase our speed. We can set up different configs for different directories.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#changing git add to ga</span>
git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>alias.ga<span class="w"> </span><span class="s2">&quot;git add&quot;</span>


<span class="c1">#changing git log --oneline to glo</span>
git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>alias.glo<span class="w"> </span><span class="s2">&quot;git log --oneline&quot;</span>
</code></pre></div>
<h2 id="moving_to_another_commit">Moving to another Commit<a class="headerlink" href="#moving_to_another_commit" title="Permanent link">&para;</a></h2>
<p>We can move to an old commit. And this will restore our working directory to the snapshot stored in that commit. So our working directory will look exactly like that commit.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># let the commit hash we wanna check in is 56rce</span>
git<span class="w"> </span>checkout<span class="w"> </span>56rce
</code></pre></div>
<p>Now you can see a warning saying that. You are in a detached head state. Here is what it is; see how git keeps track of commits. Each commit we created references the previous commit. See below, how git can maintain history.</p>
<p><img alt="Commitref" src="../img/CommitRef.png" /></p>
<p>In git and other version control systems, there is a concept called branching. We can have multiple branches to work on different features in isolation. Every git repository has a default branch called Master, the main line of work. The way git represents branches is by using a pointer. So, as we create new commits, the Master moves to the latest commits. Because we can have multiple branches, git needs to know what branch we are currently working on. For that, it uses another unique pointer called HEAD. So, HEAD points to the current branch we are working on. In this case, Master</p>
<p><img alt="Master-Head" src="../img/Master-Head.png" /></p>
<p>You must have seen this before. When we do log there, it specifies (HEAD -&gt; Master). As we create new commits, these two pointers move forward.
Here is the thing: when we check out a particular commit, HEAD moves to that specific commit. This is what we call a detached head state.</p>
<p><img alt="Checkout" src="../img/Checkout.png" /></p>
<p>At this point, we should not create new commits because if we make a new one, those commits will be added over HEAD. At some point, we have to add the HEAD pointer again to the master branch. This commit we just created is not reachable, like a dead commit. Git checks for these types of commits periodically and removes them. Then we will lose all our work. We should only look around and make experimental changes.</p>
<p><img alt="DeadCommit" src="../img/DeadCommit.png" /></p>
<p>You can see in the above image, no node is pointing to a new node when we are traversing from the Master branch, once the HEAD moves to its position.</p>
<p>When we are in a detached HEAD state. We don't see all other commits when we logged history.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Lists the commits from First Commit to current HEAD Commit.</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline


<span class="c1">#To List all the commits, we should use this command</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--all
</code></pre></div>
<p>Atlast, To attach HEAD pointer to master</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>checkout<span class="w"> </span>master
</code></pre></div>
<h1 id="branching">Branching<a class="headerlink" href="#branching" title="Permanent link">&para;</a></h1>
<p>A branch in Git is a straightforward concept. It's a lightweight, movable pointer to one of the commits. The default branch name in Git is master. As you make commits, you're given a master branch pointing to your last commit. Every time you commit, the master branch pointer moves forward automatically, making it easy to track your progress.
Branching in Git is a powerful tool that allows us to diverge from the main line of work and work in isolation. This means you can experiment, test, and develop new features without fearing disrupting the main project. It's like having your sandbox, giving you the freedom and control to work on your tasks without affecting others.</p>
<ul>
<li>It is typically created when our code is unstable when we successfully fix all bugs and merge into the master branch. This is called merging. So, branching allows us to work on different items without messing up with the main line of work.</li>
<li>We keep the main line as stable as possible. So we can release it at any time.
  The way Git manages branches is unique and efficient compared to other VCSs. For instance, in subversion, when we create a new branch, the total content of the main branch is copied to it, which can be time-consuming and space-wasting. But in Git, branches are just pointers to the commit, making it a more streamlined and resource-friendly process.</li>
<li>When we create a new branch, Git creates a new pointer that can be moved around.</li>
<li>This pointer is just a tiny file that contains a 40-byte commit ID; when we create new commits, Git moves this pointer accordingly. The master pointer stays where it is. So Git knows the latest code for each branch. So when we switch to master, Git takes the snapshot that master points to and resets that with the working directory.</li>
</ul>
<p>But how does Git know What branch we are working on? Using a unique pointer called HEAD. It is also just another tiny file. That contains the name of the branch. When we move to different branches, Git moves this pointer around. It updates the small file and changes the name of the branch.</p>
<h2 id="branch_management">Branch Management<a class="headerlink" href="#branch_management" title="Permanent link">&para;</a></h2>
<p>To create a new branch</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>branch<span class="w"> </span>bugfix
</code></pre></div>
<p>To see the list of branches</p>
<div class="highlight"><pre><span></span><code><span class="c1">#When you use this command, you get all branches, and you can see asterisks(*) before the current branch you are in</span>
git<span class="w"> </span>branch


<span class="c1">#You also see what branch you are in by status</span>
git<span class="w"> </span>status
</code></pre></div>
<p>To switch into a new branch</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Modern command</span>
git<span class="w"> </span>switch<span class="w"> </span>bugfix


<span class="c1">#Older command</span>
git<span class="w"> </span>checkout<span class="w"> </span>bugfix
</code></pre></div>
<p>To change the name of the branch</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Do not rename branches that are still in use by other collaborators.</span>
<span class="c1">#In real world, we are having hundreds of bugfixes, So it better to keep a generic name</span>
git<span class="w"> </span>branch<span class="w"> </span>-m<span class="w"> </span>bugfix<span class="w"> </span>bugfix/signup-form
</code></pre></div>
<p>After working on the bugfix branch. When you see the log of commits, you can see that HEAD is now pointing to a new branch.</p>
<p><img alt="NewBranch" src="../img/NewBranch.png" /></p>
<p>After switching to the master branch and see the log of commits.</p>
<p><img alt="orginal" src="../img/orginal.png" /></p>
<p>You can see that the commit we made in another branch is not logged here, and HEAD is pointing to a newer commit in an older branch. This is the beauty of branching; it allows us to work on something in isolation. Also, git resets the current snapshot of this branch's commit with the working directory. We must give the --all flag if you want to see all other commits over the repository.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--all
</code></pre></div>
<p><img alt="glo-all" src="../img/glo-all.png" /></p>
<p>Once we merge the bugfix branch into master branch, we need to delete it. By default git prevents us from deleting a branch, if it is not merged. And also you cannot delete the branch you are currently in.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#To delete the branch that is merged</span>
git<span class="w"> </span>branch<span class="w"> </span>-d<span class="w"> </span>bugfix

<span class="c1">#To delete a branch that is not merged</span>
<span class="c1">#If you are sure then, use force -D</span>
git<span class="w"> </span>branch<span class="w"> </span>-D<span class="w"> </span>bugfix
</code></pre></div>
<p>There are few different ways to compare branches.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Log all commits, that are in bugfix not in master</span>
git<span class="w"> </span>log<span class="w"> </span>master..bugfix

<span class="c1">#If you want to see actual changes</span>
git<span class="w"> </span>diff<span class="w"> </span>master..bugfix

<span class="c1">#If you are currently on master, you can use</span>
git<span class="w"> </span>diff<span class="w"> </span>bugfix

<span class="c1">#If you want to see what files have been changed</span>
git<span class="w"> </span>diff<span class="w"> </span>--name-only<span class="w"> </span>bugfix
</code></pre></div>
<h2 id="merging">Merging<a class="headerlink" href="#merging" title="Permanent link">&para;</a></h2>
<p>Merging is all about bringing changes from one branch to another. In git, we have two types of merges.</p>
<ul>
<li>Fast Forward Merges</li>
<li>Three Way Merges
  You can understand these from the following examples.</li>
</ul>
<h2 id="fast_forward_merge">Fast Forward Merge<a class="headerlink" href="#fast_forward_merge" title="Permanent link">&para;</a></h2>
<p>If two branches have not diverged and there is a direct linear path from the target branch to source branch, Git runs a fast-forward merge; it simply moves the pointer from source to target branch. After we can simply remove the bugfix branch
<img alt="FF" src="../img/FF.png" /></p>
<h2 id="three_way_merge">Three Way Merge<a class="headerlink" href="#three_way_merge" title="Permanent link">&para;</a></h2>
<p>In the previous example, there is a direct linear path. But What if the main branch master also gets committed? Now, the branches have diverged. We have some changes in the master that don't exist in the bugfix branch. If you run a merge, git cannot move the master pointer directly forward and have it point to the same commit as the bugfix branch. Otherwise, we will lose the latest commit in the master. So, when we run a merge, git creates a new commit that combines the changes between these two branches. This is called a three-way merge because this new commit is based on three different commits of 1, 2, and 3 in the diagram below.</p>
<p>1 - The common ancestors of the both branches, which includes the before code.</p>
<p>2, 3 - And the tips of our branches, which contain after code.</p>
<p>4 - Is a merge Commit</p>
<p><img alt="3-way" src="../img/3-way.png" /></p>
<h2 id="fast_forward_merge_1">Fast Forward Merge<a class="headerlink" href="#fast_forward_merge_1" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">#To get changes of bugfix to master, we should be on master branch</span>
git<span class="w"> </span>merge<span class="w"> </span>bugfix
</code></pre></div>
<p>As you can see below, the bugfix branch is one commit ahead of master and also there is a direct linear path. So when we run a merge, git will fast forward master.</p>
<p><img alt="ff" src="../img/glo-all.png" /></p>
<p>After fast forward merge, it shows statistics of what has been changed.</p>
<p><img alt="ff-merge1" src="../img/ff-merge1.png" /></p>
<p>After we log commit. We can see both branches pointing to same commit.</p>
<p><img alt="gloafterff" src="../img/glo-after-ff1.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1">#Every time you create a branch, you have to switch to that branch which is two steps. You can run this single step</span>
git<span class="w"> </span>switch<span class="w"> </span>-C<span class="w"> </span>newbugfix
</code></pre></div>
<p>And also, before introducing branching all our history is linear, but after it may be nonlinear, So you should use --graph flag too</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--all<span class="w"> </span>--graph
</code></pre></div>
<p>Suppose we want to avoid doing a fast-forward merge. Here is how you can do it.
As you can see below, the newbugfix branch is one commit ahead of the master. There is a linear and direct path, But we are not interested.</p>
<p><img alt="glonoff" src="../img/glonoff.png" /></p>
<p>Switch to master. And run this flag --no-ff, Editor opens asking you a message for merge commit.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>merge<span class="w"> </span>--no-ff<span class="w"> </span>newbugfix
</code></pre></div>
<p>After running the log command with --graph flag. Here is how it is</p>
<p><img alt="gloafternoff" src="../img/gloafternoff.png" /></p>
<p>We can merge commits in both ways. It comes down to your preference. But --no-ff merges are a true reflection of our history. But they pollute history. But --no-ff allows reverting a commit quickly.</p>
<p>Fast forward, merge is default. But you can configure that.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#To remove fast forward as default in globally in all repositories</span>
git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>ff<span class="w"> </span>no
</code></pre></div>
<h2 id="three_way_merge_1">Three way merge<a class="headerlink" href="#three_way_merge_1" title="Permanent link">&para;</a></h2>
<p>See below example. Where only three way merge is possible.</p>
<p><img alt="3-way-node" src="../img/3-way-node.png" /></p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--all<span class="w"> </span>--graph
</code></pre></div>
<p>You can see that after running this command. We get this, you can see there is no direct linear path from master to feature branch.</p>
<p><img alt="3-way-merge" src="../img/3-way-merge.png" /></p>
<p>So when we try to merge, git is going to run a three way merge. It's gonna look at tips of the branches, Then it is gonna compare it with their common ancestor. Based on the differences it's gonna figure out how to merge or combine the changes into a new merge commit.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#from master branch</span>
git<span class="w"> </span>merge<span class="w"> </span>feature
</code></pre></div>
<p>Here is how it looks after a 3 way merge.</p>
<p><img alt="glo-after-3" src="../img/glo-after-3.png" /></p>
<p>To know the list of branches, that merged to master branch</p>
<div class="highlight"><pre><span></span><code><span class="c1">#lists all branches that are merged to current branch</span>
git<span class="w"> </span>branch<span class="w"> </span>--merged


<span class="c1">#lists all branches that are not merged to current branch</span>
git<span class="w"> </span>branch<span class="w"> </span>--no-merged
</code></pre></div>
<p>After that, it is safe to delete all these branches. As a best practice, you should delete it whenever you are done working on a branch.</p>
<h2 id="merge_conflicts">Merge Conflicts<a class="headerlink" href="#merge_conflicts" title="Permanent link">&para;</a></h2>
<p>In the real world, quite often. When we merge branches, we run into conflicts. Conflicts happen when</p>
<h3 id="conflicts">Conflicts<a class="headerlink" href="#conflicts" title="Permanent link">&para;</a></h3>
<ul>
<li>The same line of the code has been changed in two different branches in different ways.</li>
<li>If a file is changed in one branch and deleted in another.</li>
<li>When a file with the same name is added in two branches, the content is different.
  In these cases, git cannot figure out how to merge changes. So it will stop the process, and that's where we should tell the git how to proceed.</li>
</ul>
<p>See below example. Where I have modified the same file, same line from different branches and committed. Here is how the log looked</p>
<p><img alt="glomerge" src="../img/glomerge.png" /></p>
<p>Afterwards, when I tried to merge these into master. I saw this message.</p>
<p><img alt="gitmerge" src="../img/gitmerge.png" /></p>
<p>Once you get into a conflict, you will be in the middle of the merge process.</p>
<p><img alt="mergestatus" src="../img/mergestatus.png" /></p>
<p>Here is how objectives.txt look, when I tried to open.</p>
<p><img alt="mergelook" src="../img/mergelook.png" /></p>
<p>You can see markers indicating what has changed in both branches. And also 4 Text-like buttons on top. We can either use those buttons or manually edit and remove those markers. As a best practice, we should not add a new line of code when resolving a conflict. Once you manually resolve conflicts. You should stage them and commit.</p>
<h2 id="undoing_a_faulty_merge">Undoing a faulty merge.<a class="headerlink" href="#undoing_a_faulty_merge" title="Permanent link">&para;</a></h2>
<p>What if, after resolving a merge conflict. Our application had a bug, or we need to merge it better.
One option is to remove this commit as if it was never there. You have to be careful because you are rewriting history. Rewriting history is entirely acceptable once you have yet to push your code or haven't shared it with others. In other situations, instead of removing this commit, we should revert it. This will create a new commit that will cancel all the changes in this commit.</p>
<p>Let's see how to remove the last commit. Using the reset command, both the HEAD and master will move to the ancestor of both branches. In 2, you can see that no pointer is pointing to the merge commit. Git will constantly see these types of nodes and remove them occasionally.</p>
<p>You should do this only if you have yet to share the history.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>reset<span class="w"> </span>--hard<span class="w"> </span>HEAD~1
</code></pre></div>
<p><img alt="p4merge" src="../img/undoing.png" /></p>
<p>While resetting, we have three options.</p>
<ul>
<li>soft (the last commit is undone, and the staging area and working directory are not affected )</li>
<li>mixed (the last commit is undone, and both the last commit and staging area look the same; this is the default option )</li>
<li>hard (the last commit is undone, and all three environments look the same )</li>
</ul>
<p>But if we shared our history. Instead of undoing it, we have to revert to the last commit.
While reverting a merge commit, we have to tell git how we want to revert the commit because a merge commit has two parents.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Revert to the first parent. THe first parent will be in the master branch.</span>
git<span class="w"> </span>revert<span class="w"> </span>-m<span class="w"> </span><span class="m">1</span>
</code></pre></div>
<h2 id="squash_merging">Squash Merging<a class="headerlink" href="#squash_merging" title="Permanent link">&para;</a></h2>
<p>Squash Merging is a technique that combines multiple commits into a single commit when merging a branch. This is often used to simplify commit history. When you perform a squash merge, all the changes from the branch are squashed into one new commit on the target branch. This can be useful in maintaining a neat, clean and understandable history.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#It doesn&#39;t create a commit. It just stages the changes.</span>
git<span class="w"> </span>merge<span class="w"> </span>--squash<span class="w"> </span>newbranch


<span class="c1">#So now we have to make a commit. With a good message representing all changes</span>
git<span class="w"> </span>commit<span class="w"> </span>-am<span class="w"> </span><span class="s2">&quot;Good message&quot;</span>
</code></pre></div>
<p>It is super important to delete the target branch, once it is squashed because when we see merged branches, it will not be there and creates a mess in future. Also when you are trying to delete this branch, it will show an error saying that this branch is not fully merged. So we have to force delete using the -D flag.</p>
<h2 id="rebasing">Rebasing<a class="headerlink" href="#rebasing" title="Permanent link">&para;</a></h2>
<p>In Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase.</p>
<p><img alt="rebase1" src="../img/rebase1.png" /></p>
<p>Now using the rebase command, we can change the base of our branch, So we can base it on the latest commit on master.
<img alt="rebase2" src="../img/rebase2.png" /></p>
<p>We can see above that we have a direct linear path. Now we can simply do a fast forward merge. Now we have linear history.</p>
<p>This sounds like a great idea. We need to be cautious while rebasing. Because rebasing rewrites history. So you need to use rebasing only if your commits are local.</p>
<p>If you have pushed your changes or shared your code, you should not use rebasing. Here is why? When you rebase, you are rewriting the history of the branch. So when you push your changes, you are rewriting the history of the remote repository. This will create a lot of confusion and problems for your team members. So, if you have shared your code, you should not use rebase.</p>
<p>See below, example. When we use rebase, git will not change the parent of the feature branch, because commits in git are immutable. So, instead it creates exact copies of those two commits and points them to Master. Then it gonna move feature pointer to B2*, now both B1 and B2 are disconnected, which eventually removed by git.</p>
<p><img alt="rebase3" src="../img/rebase3.png" /></p>
<p>If someone had created new commits on top of B2, their history is gonna be lost, because there will be no linear path to B2.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#You should be on target branch to do rebase</span>
git<span class="w"> </span>switch<span class="w"> </span>feature

<span class="c1">#After run rebase</span>
git<span class="w"> </span>rebase<span class="w"> </span>master

<span class="c1">#After rebase we should, merge chnages</span>
git<span class="w"> </span>switch<span class="w"> </span>master

git<span class="w"> </span>merge<span class="w"> </span>feature
</code></pre></div>
<p>Quite frankly, when we try to rebase we will end up getting merge conflicts. P4merge is very good, when we are rebasing.
So, After resolving conflict for the first time.You should continue rebase</p>
<div class="highlight"><pre><span></span><code><span class="c1"># To tell git to apply next commit, on top of master</span>
git<span class="w"> </span>rebase<span class="w"> </span>--continue

<span class="c1"># If the next commit also has conflict, then we&#39;re gonna end up in the same state.</span>
<span class="c1"># We should resolve the conflict and tell git to continue rebasing.</span>

<span class="c1"># We have another option --abort, this is useful when you have applied,</span>
<span class="c1"># So many commits on top of master or perhaps your branches are diverged for a long time or you don&#39;t have time.</span>
git<span class="w"> </span>rebase<span class="w"> </span>--abort
<span class="c1"># This will take us to the state, before we start rebasing.</span>
</code></pre></div>
<h1 id="collaboration">Collaboration<a class="headerlink" href="#collaboration" title="Permanent link">&para;</a></h1>
<p>As discussed previously, Git is a Distributed Version Control System. Everyone has their local repository, but they also use a central repository to synchronize their work. This is the workflow used in most private teams and closed-source projects. We don't have a single point of failure. If the central repository is unavailable, we can synchronize our work. Some organizations put this central repository on servers on their private network. Others use git hosting platforms like GitHub, GitLab, BitBucket, etc. With all these servers, we can set up our repository as a private one accessible only to our team members.</p>
<h2 id="centralized_workflow">Centralized Workflow<a class="headerlink" href="#centralized_workflow" title="Permanent link">&para;</a></h2>
<p>If two developers clone from the hub and both make changes, the first developer to push their changes back up can do so without problems. The second developer must merge in the first one's work before pushing changes up not to overwrite the first developer's changes. This concept is as accurate in Git as it is in Subversion (or any CVCS), and this model works perfectly well in Git.</p>
<p>See below diagram</p>
<ol>
<li>Both contributors first clone the repository from the central repository. Now, they both have a local repository on their machine.</li>
<li>So, persons A and B start working and make some commitments. After some point in time, A wants to share his work. To do that, he uses the push command to send his changes to the central repository.</li>
<li>The central repository is now in sync with A's work. Now, B gets the changes from the main repository using the pull command.</li>
<li>If B has any conflicts, she will resolve the conflicts and push the changes.</li>
<li>A will after pull these changes.</li>
</ol>
<p><img alt="cw-1" src="../img/cw-1.png" /></p>
<h2 id="integration_workflow">Integration Workflow<a class="headerlink" href="#integration_workflow" title="Permanent link">&para;</a></h2>
<p>Open source projects thrive on the contributions of many, including maintainers and numerous contributors. While we may not know each contributor personally, their role is crucial. As a result, we cannot grant push access to all. Only the maintainers have this privilege, ensuring the integrity of the repository.</p>
<p>Contributing to our open-source project is a straightforward process you can easily follow. Here are the steps:</p>
<ol>
<li>First, fork the project.</li>
<li>We clone the forked repository to work locally.</li>
<li>Later, we make a few commits and then push them to our forked repository.</li>
<li>Next, we will send a Pull Request to the project's maintainer.</li>
<li>They get notified if they want our work. They pull in our changes and review them.</li>
<li>If they like it, they will merge our changes.</li>
</ol>
<p><img alt="im" src="../img/im.png" /></p>
<p>We can create a repository from GitHub UI, we can make it Public or Private according to our needs. Later we can export our local repository to GitHub.</p>
<p>Even though a repository is public, no one can make changes. But they can see our code and commit history. If you are working on a team, then you should give your team members push access.</p>
<p>Adding Collaborators. Go to settings on the top repository nav bar.</p>
<p><img alt="collo" src="../img/collo.png" /></p>
<p>Cloning Repository. Every team member should clone the repository; that means you should take a copy of this repository and put it on their machine. Locally, they will work with that repository, and when they are ready to share their changes, they will push their commits to the central repository. To clone.</p>
<p><img alt="clone" src="../img/clone.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1"># Clones the repository in the current directory.</span>
<span class="c1"># And directory name in our local will be default to is Repository name. Which you can change</span>
git<span class="w"> </span>clone<span class="w"> </span>&lt;url&gt;

<span class="c1">#You can optionally give a name directly while cloning</span>
git<span class="w"> </span>clone<span class="w"> </span>&lt;url&gt;<span class="w"> </span>MyRepo
</code></pre></div>
<p>After cloning view the log, you can see one other branch and one other pointer for that branch.</p>
<p><img alt="origin" src="../img/origin.png" /></p>
<p>When we clone our repository, git names the source repository as the origin. So, the origin is a reference to that repository, and the origin/master tells us where the master branch is in that repository. Now, we have multiple repositories, and history can evolve independently. So, the origin/master tells us where the origin branch is in that repository; technically, this is called a remote-tracking branch. It's not a branch; we cannot check it out but commit to it. Even if we logged all the branches, we could not see the origin of the branch. To learn about the remote branch, use this command.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>remote
</code></pre></div>
<p>For more verbose.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>remote<span class="w"> </span>-v
</code></pre></div>
<h2 id="fetching">Fetching<a class="headerlink" href="#fetching" title="Permanent link">&para;</a></h2>
<p>Our local repository is not connected to the remote repository; if we have a new commit in our remote repository, our local repository is unaware of that. Here, we must use the fetch command to download the remote changes. It downloads the new changes and updates the origin/master accordingly. So, as we discussed before, origin/master is a remote-tracking branch and tells us where the master branch is in a remote repository. Even though we downloaded this new commit. Our working directory needs to be updated. To update the working directory, we need to update the master branch.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># To fetch the changes from origin master</span>
git<span class="w"> </span>fetch

<span class="c1"># To fetch the changes to only specific branch</span>
git<span class="w"> </span>fetch<span class="w"> </span>origin<span class="w"> </span>branchname
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">#If branches are not diverged, then we are going to have fast forward merge or if we have any conflicts we should resolve them.</span>
git<span class="w"> </span>merge<span class="w"> </span>origin/master
</code></pre></div>
<p>Another command that we should be familiar is</p>
<div class="highlight"><pre><span></span><code><span class="c1">#shows how our local and remote branches are diverged</span>
git<span class="w"> </span>branch<span class="w"> </span>-vv
</code></pre></div>
<h2 id="pulling">Pulling<a class="headerlink" href="#pulling" title="Permanent link">&para;</a></h2>
<p>To bring changes from remote repository to local repository, we have to do two steps fetch+merge</p>
<p>We have a command that combines the two, pull = fetch + merge. Lets see the example below. In our local repository there is a commit which is not shared with the remote repository and in the remote repository we have a commit that has not been fetched.</p>
<p><img alt="pull" src="../img/pull.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1">#fetch + merge</span>
git<span class="w"> </span>pull
</code></pre></div>
<p>After pull, the above will be converted to this in a series of steps. (3-way-merge)</p>
<p><img alt="pull1" src="../img/pull1.png" /></p>
<p>Alternatively we can do rebasing. Here is what it does, in local we are on master branch, when we do rebase, the master branch will be rebase. This means, for some other contributor changes, our local history is gonna be overwritten. That is perfectly fine.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>pull<span class="w"> </span>--rebase
</code></pre></div>
<p><img alt="pull2" src="../img/pull2.png" /></p>
<p>With this, we will simply end up in linear history.</p>
<h2 id="pushing">Pushing<a class="headerlink" href="#pushing" title="Permanent link">&para;</a></h2>
<p>In the below example you can see that our local repository is one commit ahead of origin/master branch. So we can use the push command, to send this new commit to origin/master.</p>
<p><img alt="push1" src="../img/push1.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1">#defaultly pushes master to remote</span>
git<span class="w"> </span>push


<span class="c1">#to push other branches</span>
git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>branchname
</code></pre></div>
<p>After pushing, here is what it looks like. When we do push, first our commit B goes to remote repository and master points to the new commit B, and after in local, origin/master also updates to B</p>
<p><img alt="push2" src="../img/push2.png" /></p>
<p>Sometimes, our push gets rejected because, Before we are doing a push if some other pushed to the same repository. Then, we should again do a pull, and do a push.</p>
<h2 id="storing_credentials">Storing Credentials<a class="headerlink" href="#storing_credentials" title="Permanent link">&para;</a></h2>
<p>We don't wanna enter our credentials, every time we do a push, that is very tedious and time consuming. You should config them</p>
<div class="highlight"><pre><span></span><code><span class="c1"># git will store our credentials for 15 minutes in memory</span>
git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>credential.helper<span class="w"> </span>cache

<span class="c1"># Stores the credential permanently for Linux in an encrypted way. But first we need to install store</span>
<span class="c1"># Run first this command, to know whether is there. If not, you can see instructions to install.</span>
git<span class="w"> </span><span class="nb">help</span><span class="w"> </span>-a<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>credential-store

<span class="c1"># Run this to set it to store.</span>
git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>credential.helper<span class="w"> </span>store

<span class="c1"># Stores the credential permanently for MacOS in an encrypted way. But first we need to install Keychain.</span>
<span class="c1"># Run first this command, to know whether Keychain is there. If not, you can see instructions to install.</span>
git<span class="w"> </span>credential-osxkeychain
<span class="c1"># Run this to set to Keychain</span>
git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>credential.helper<span class="w"> </span>osxkeychain

<span class="c1"># Stores the credential permanently for Windows in an encrypted way.</span>
<span class="c1"># But you need to install Git-Credential-Manager-for-Windows</span>
git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>credential.helper<span class="w"> </span>manager
</code></pre></div>
<h2 id="sharing_tags">Sharing Tags<a class="headerlink" href="#sharing_tags" title="Permanent link">&para;</a></h2>
<p>By default, push command doesn't transfer our tags to a remote repository. We have to explicitly push them.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#pushes tag named vname</span>
git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>vname

<span class="c1">#If we want to delete the tag</span>
git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>--delete<span class="w"> </span>vname
</code></pre></div>
<h2 id="releases">Releases<a class="headerlink" href="#releases" title="Permanent link">&para;</a></h2>
<p>One of the github features that goes hand in hand with tags is release management. We can create a release to package our software along with the source code, binary files and release notes. It is just a github feature.</p>
<h2 id="sharing_branches">Sharing branches<a class="headerlink" href="#sharing_branches" title="Permanent link">&para;</a></h2>
<p>Similar to tags our branches or local by default. So, if you want to collaborate with other team members using a branch, we have to explicitly push that branch.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># To see all remote tracking branches, we can use</span>
git<span class="w"> </span>branch<span class="w"> </span>-r
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># The first time, you push a branch which does not have an upstream</span>
git<span class="w"> </span>push<span class="w"> </span>-u<span class="w"> </span>origin<span class="w"> </span>branchname
</code></pre></div>
<p>Now we can start working with these branches, the same way we work with master branches. At some time, after your work is done, you should delete the branch, in locally as well as remotely.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># deletes branch in origin</span>
git<span class="w"> </span>push<span class="w"> </span>-u<span class="w"> </span>-d<span class="w"> </span>origin<span class="w"> </span>branchname
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># We want this branch to be in the same place as the origin branch, which is created from GitHub.</span>
git<span class="w"> </span>switch<span class="w"> </span>-C<span class="w"> </span><span class="nb">local</span><span class="w"> </span>branch<span class="w"> </span>originbranch
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># After implementing some features in a branch, even though we deleted them in origin, we should also delete them locally.</span>
git<span class="w"> </span>remote<span class="w"> </span>prune<span class="w"> </span>origin
</code></pre></div>
<h2 id="pull_requests">Pull Requests<a class="headerlink" href="#pull_requests" title="Permanent link">&para;</a></h2>
<p>Often, it is part of fixing a bug or implementing a feature. We want other members' feedback about our code. This is where we open a Pull Request. We essentially open a discussion in a team before merging and branching to master. We should also resolve conflicts in precisely the same way as discussed above.</p>
<p><img alt="pr" src="../img/pr.png" /></p>
<p>We can also open issues. Assign issues, create labels for issues, create milestones.</p>
<h2 id="contributing_to_open_source">Contributing to open source<a class="headerlink" href="#contributing_to_open_source" title="Permanent link">&para;</a></h2>
<p>You don't have push access to the repository, only maintainers have. So first we need to fork this repository, github will take a complete copy of this repository and keep it in your account. You have complete access to this repository. After we clone the repository and work locally. Starting a pull request is exactly the same, but the only difference is we have two repositories.</p>
<h3 id="keeping_a_forked_repository_up_to_date">Keeping a forked repository up to date.<a class="headerlink" href="#keeping_a_forked_repository_up_to_date" title="Permanent link">&para;</a></h3>
<p>We forked an open-source project to contribute to it. Now, there is a problem: this forked repository is not connected to the original repository, which means this is independent from the original repository, so from time to time, it can get out of sync with the base repository. Because other people contribute to the base repository and add new commits to the main branch, we will not be aware of this. We should keep this forked repository up to date. We have a reference for our forked repository in our local repository. We can also add another reference to the central repository and use the pull command to bring in the changes, and we can push them to our forked repository.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#to know about remote repository</span>
git<span class="w"> </span>remote<span class="w"> </span>-v
</code></pre></div>
<p>Now to add a new remote</p>
<div class="highlight"><pre><span></span><code><span class="c1"># You can name main repo or whatever you need, not only upstream</span>
git<span class="w"> </span>remote<span class="w"> </span>add<span class="w"> </span>upstream<span class="w"> </span>&lt;main<span class="w"> </span>repo<span class="w"> </span>url&gt;

<span class="c1"># To rename the remote repository</span>
git<span class="w"> </span>remote<span class="w"> </span>rename<span class="w"> </span>upstream<span class="w"> </span>base

<span class="c1"># If you want to remove the remote</span>
git<span class="w"> </span>remote<span class="w"> </span>rm<span class="w"> </span>base
</code></pre></div>
<p>Back in our local repository, we need to use fetch or pull command to bring in the changes</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>fetch<span class="w"> </span>base
</code></pre></div>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>merge<span class="w"> </span>base/master
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">#To push changes into forked repository</span>
git<span class="w"> </span>push
</code></pre></div>
<h1 id="rewriting_history">Rewriting History<a class="headerlink" href="#rewriting_history" title="Permanent link">&para;</a></h1>
<p>One powerful yet potentially risky feature at your disposal is the ability to rewrite history.</p>
<ul>
<li>We can drop or modify commits, combine or split them, etc.</li>
<li>If our commit messages lack meaning, are too large, contain unrelated changes, or are too small, we can rewrite history. It's our responsibility to maintain a clean, readable history that tells the complete story of our project.</li>
<li>If we have small related commits, we can squash them into a single commit representing a logical chain set.</li>
<li>If we have large commits that contain a lot of unrelated changes, we can split them into a bunch of smaller commits, each representing a logically different chain set.</li>
<li>We can also reword commits. If we commit by accident, we can change the content of that commit. These can help maintain a neat and readable history. But remember, rewriting history can be a dangerous operation. You need to know what you are doing.</li>
</ul>
<h2 id="the_main_rule_for_rewriting_history">The Main Rule For Rewriting History.<a class="headerlink" href="#the_main_rule_for_rewriting_history" title="Permanent link">&para;</a></h2>
<p>Don't rewrite public history; if you have shared your work with others, those commits are considered public, and you should not modify them. Because commits in git are immutable, they cannot be changed once we create them. See below example</p>
<p><img alt="rule" src="../img/rule.png" /></p>
<p>You can see that when we are trying to rewrite B commit, git creates a new commit like B and moves the master to that new commit B*, making commit B unreachable. When we try to push, git will reject our push. Because as you can see in our history, our master branches have diverged. In this case, first, we have to merge origin/master with master, and then we can do a push. But we have created a non-linear, noisy history. We wanted to modify B and replace it with something better, creating two new commits.</p>
<p><img alt="rule2" src="../img/rule2.png" /></p>
<p>But here you can follow another approach, use the force option. This removes the B commit in origin and adds B<em>, and moves the origin/master to B</em> locally.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># First try this command. If it is rejected, then you can use force option</span>
git<span class="w"> </span>push<span class="w"> </span>--force-with-lease

<span class="c1">#You should not use the force option always, it is destructive.</span>
git<span class="w"> </span>push<span class="w"> </span>--force
</code></pre></div>
<p>Remember this Main Rule For ReWriting History always, DON'T REWRITE THE PUBLIC HISTORY.
Once you made it public it is final. Unless you have a strong reason in doing so. Rewriting history in your local repository is entirely fine. In Fact you need to do that.</p>
<h2 id="undoing_commits">Undoing Commits<a class="headerlink" href="#undoing_commits" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">#Removes the commit only</span>
git<span class="w"> </span>reset<span class="w"> </span>--soft<span class="w"> </span>HEAD~1


<span class="c1">#unstages the files</span>
git<span class="w"> </span>reset<span class="w"> </span>--mixed<span class="w"> </span>HEAD~1


<span class="c1">#Discard local files</span>
git<span class="w"> </span>reset<span class="w"> </span>--hard<span class="w"> </span>HEAD~1
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">#Shows the diff between current staging area and present commit</span>
git<span class="w"> </span>diff<span class="w"> </span>--cached
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">#This simply unstage all changes.</span>
git<span class="w"> </span>reset<span class="w"> </span>--mixed<span class="w"> </span>HEAD


<span class="c1">#Mixed is default option</span>
git<span class="w"> </span>reset<span class="w"> </span>HEAD
</code></pre></div>
<h2 id="reverting_commits">Reverting Commits<a class="headerlink" href="#reverting_commits" title="Permanent link">&para;</a></h2>
<p>As discussed above, resetting HEAD is not an option here. Because we don't want to drop the commits that we shared earlier. So we need to revert the commit.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#revert only 3 commits, not HEAD~3, it is just parent.</span>
git<span class="w"> </span>revert<span class="w"> </span>HEAD~3..HEAD


<span class="c1">#with --no-commit option, git is going to revert the commits and simply add the changes in the staging area. So for every commit we gonna revert git will figure out the changes to be undone and then apply to the staging area.</span>
git<span class="w"> </span>revert<span class="w"> </span>--no-commit


<span class="c1">#You can also abort the revert</span>
git<span class="w"> </span>revert<span class="w"> </span>--abort


<span class="c1">#If you want to continue</span>
git<span class="w"> </span>revert<span class="w"> </span>--continue
</code></pre></div>
<h2 id="recovering_lost_commits">Recovering Lost Commits<a class="headerlink" href="#recovering_lost_commits" title="Permanent link">&para;</a></h2>
<p>With git we don't really lose anything. All the information about our project history, all the commits that we have created, all of the objects are stored in our repository. Even if we don't see them when looking at the history. So, git keeps all of these objects for a while, if they are not useful git will garbage collect.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Shows the list of movements of the head. There you can also see a hash of that commit.</span>
git<span class="w"> </span>reflog


<span class="c1">#After with that hash, you can simply reset</span>
git<span class="w"> </span>reset<span class="w"> </span>--hard<span class="w"> </span><span class="nb">hash</span>


<span class="c1">#By default reflog shows the HEAD of master.</span>
<span class="c1">#But if you want to see, other refs in other branches</span>
git<span class="w"> </span>reflog<span class="w"> </span>show<span class="w"> </span>branchname
</code></pre></div>
<h2 id="amending_the_last_commit">Amending The Last Commit<a class="headerlink" href="#amending_the_last_commit" title="Permanent link">&para;</a></h2>
<p>There are a lot of cases, we make a commit and then we realize we made a mistake, perhaps a typo or we accidentally included a file. In these situations you can amend or modify the commit.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>commit<span class="w"> </span>--amend<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;New message&quot;</span>


<span class="c1">#If you don&#39;t want to enter a new message, you can pass --no-edit</span>
git<span class="w"> </span>commit<span class="w"> </span>--amend<span class="w"> </span>--no-edit
</code></pre></div>
<p>We don't really modify the commit as discussed previously, commits are immutable.</p>
<h1 id="amending_an_earlier_commit">Amending an earlier commit<a class="headerlink" href="#amending_an_earlier_commit" title="Permanent link">&para;</a></h1>
<p>Let's say you want to amend a commit of hash "hash" and its parent's hash is "parent"
With Interactive rebasing, we can replay a bunch of commits on top of another commit. We gonna rebase commit with commit id "hash" and all the future commits on top of the parent of this commit or commit id "parenthash"</p>
<div class="highlight"><pre><span></span><code><span class="c1"># -i for interactive, so we&#39;re gonna stop it, make changes and continue.</span>
git<span class="w"> </span>rebase<span class="w"> </span>-i<span class="w"> </span><span class="s2">&quot;parenthash&quot;</span>
</code></pre></div>
<p>This is the script for the above operation. It contains a series of instructions about rebase operation. Here you can edit more than one commit, if you edit a commit all the future commits of that parent commit will change.</p>
<p><img alt="rebase" src="../img/rebase.png" /></p>
<p>Actually, as we already discussed when we rebase a commit, git creates new commits and changes their pointers. Even if we are changing a single commit, all the commits after that commit will also get recreated.</p>
<p><img alt="r1" src="../img/r1.png" /></p>
<p>See, above example. Here we are trying to edit B, so git created B<em>, but now C should point to B</em>. But that is not going to be possible, because commits in git are immutable. So it recreates all those commits.</p>
<p><img alt="r2" src="../img/r2.png" /></p>
<p>So, remember rebasing is a destructive operation, because it rewrites history.</p>
<p><img alt="r3" src="../img/r3.png" /></p>
<p>Now, we are in the middle of rebase. Our head is on another commit. Now if we want to add some changes to that commit, first get those changes into the staging area and working directory.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>reset<span class="w"> </span>--hard<span class="w"> </span>HEAD
</code></pre></div>
<p>After add your changes, into staging area and then amend</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>commit<span class="w"> </span>--amend<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Rebasing&quot;</span>
</code></pre></div>
<p>Log of commits.</p>
<p><img alt="r4" src="../img/r4.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1">#now we should continue rebase</span>
git<span class="w"> </span>rebase<span class="w"> </span>--continue
</code></pre></div>
<p>Now, if you see the log you can see that you have a simple linear history. But all commit IDs are changed. This is why commits in git are immutable. The change we introduced in one of the earlier commits carried on throughout the rest of the history.</p>
<h2 id="dropping_commits">Dropping Commits<a class="headerlink" href="#dropping_commits" title="Permanent link">&para;</a></h2>
<p>While dropping commits, we come across conflicts, dropping a commit means we are essentially saying we never introduced this change. Now if in contrast the next commit is depending on this commit, then we're gonna run into a conflict. Then we should manually resolve the conflicts.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># ^refers parent of the hash</span>
git<span class="w"> </span>rebase<span class="w"> </span>-i<span class="w"> </span>hash^
<span class="c1"># make the option to drop</span>
</code></pre></div>
<h2 id="reword_commit_messages">Reword Commit Messages<a class="headerlink" href="#reword_commit_messages" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">#Now if we should change pick to reword</span>
git<span class="w"> </span>rebase<span class="w"> </span>-i<span class="w"> </span>hash^
</code></pre></div>
<p>Now after we are trying to close the window, it's gonna stop and give us a chance to change the message.</p>
<h2 id="reordering_commits">Reordering Commits<a class="headerlink" href="#reordering_commits" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>rebase<span class="w"> </span>-i<span class="w"> </span><span class="nb">hash</span>
</code></pre></div>
<p>We talked about this before, each commit stores the complete snapshot of our project. Note that commits themselves are independent but the changes they introduced might not be. While reordering commits, if one commit depends on changes introduced in another commit, you might encounter conflicts that you might need to resolve manually. You should be carefull.</p>
<h2 id="squashing_commits">Squashing Commits<a class="headerlink" href="#squashing_commits" title="Permanent link">&para;</a></h2>
<p>All the commits that represent the same logical work should be represented in a single commit. But, speaking truly sometimes that is not possible. Then you should squash them.</p>
<p>The commits which we wanna merge, take the parent of the first commit.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>rebase<span class="w"> </span>-i<span class="w"> </span>hash^
</code></pre></div>
<p>In script, change the pick command with squash. And give a commit message</p>
<h2 id="splitting_a_commit">Splitting A Commit<a class="headerlink" href="#splitting_a_commit" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>rebase<span class="w"> </span>-i<span class="w"> </span>hash^
</code></pre></div>
<p>We should change pick to edit.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#git will stop the rebase at that command</span>
git<span class="w"> </span>reset<span class="w"> </span>HEAD^
<span class="c1">#Now split changes according to your needs.</span>
</code></pre></div>
<h1 id="advanced">Advanced<a class="headerlink" href="#advanced" title="Permanent link">&para;</a></h1>
<h2 id="ls-tree">ls-tree<a class="headerlink" href="#ls-tree" title="Permanent link">&para;</a></h2>
<p>This is mainly for advanced terminal based editor users like vim, neovim , emacs...
Where we can the whole snapshot of project in detail.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Directory in the file system can be represented using a tree</span>
git<span class="w"> </span>ls-tree<span class="w"> </span>HEAD
</code></pre></div>
<p>We can see total contents at depth-0 initially, where blob represents files, they are like leaves in this tree. Each sub directory is represented with a tree. Every node is hashed with some unique identifier based on the contents present in them. All of these are objects in git's database.</p>
<p><img alt="ls-tree" src="../img/ls-tree.png" /></p>
<p>Afterwards we can see the total project structure by easily navigating these nodes. Here is how you can do it.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#unique identifier of file1.txt , displays the total content</span>
git<span class="w"> </span>show<span class="w"> </span>5b9b
</code></pre></div>
<p>Viewing tree, Then similarly we get the contents of this node</p>
<div class="highlight"><pre><span></span><code><span class="c1">#for subtree2</span>
<span class="sb">```</span>bash
git<span class="w"> </span>show<span class="w"> </span>14be7
</code></pre></div>
<p>Using the show command we can view objects in git's database.
Git Objects can be</p>
<ul>
<li>Commits</li>
<li>Blobs(Files)</li>
<li>Trees</li>
<li>Tags</li>
</ul>
<h2 id="formatting_the_log">Formatting The Log<a class="headerlink" href="#formatting_the_log" title="Permanent link">&para;</a></h2>
<p>We don't use this that often. But if you don't like how the log shows the details, you can customize it.</p>
<p>For more this type of keys. <a href="https://git-scm.com/docs/pretty-formats">Visit</a> this page</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Shows the list of commits made in this format author along with Long hash id</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--author<span class="o">=</span>nothuman2718<span class="w"> </span><span class="nv">pretty</span><span class="o">=</span>format:<span class="s2">&quot;%an committed %H&quot;</span>


<span class="c1">#Shows the list of commits made in this format author along with abbreviated hash id with date</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--author<span class="o">=</span>nothuman2718<span class="w"> </span><span class="nv">pretty</span><span class="o">=</span>format:<span class="s2">&quot;%an committed %h on %cd&quot;</span>


<span class="c1">#We can also colorize the text</span>
<span class="c1">#Shows the author name in green. Similarly for other texts.</span>
git<span class="w"> </span>log<span class="w"> </span>--oneline<span class="w"> </span>--author<span class="o">=</span>nothuman2718<span class="w"> </span><span class="nv">pretty</span><span class="o">=</span>format:<span class="s2">&quot;%Cgreen%an%Creset committed %h on %cd&quot;</span>
</code></pre></div>
<h2 id="bisect_command">Bisect Command<a class="headerlink" href="#bisect_command" title="Permanent link">&para;</a></h2>
<p>Incredibly powerful tool for finding bugs. If we don't know where the bug is introduced and don't want to check each commit. Then the bisect command comes into picture. Using the bisect command we can quickly find the commit that introduced this bug. We just have to say that the current state is a bad commit and we should also give a good commit.</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>bisect<span class="w"> </span>start

<span class="c1">#Now give the current commit as bad</span>
git<span class="w"> </span>bisect<span class="w"> </span>bad

<span class="c1">#We should also give a good commit. Where this feature is not at all present or where there is no bug</span>
git<span class="w"> </span>bisect<span class="w"> </span>good<span class="w"> </span>hashofthecommit
</code></pre></div>
<p>Now we are in a bisect state.</p>
<p>Now git says some statistics, and roughly after how many steps after will this complete. You can also see that, we are in a detached HEAD state, that means our working directory is a snapshot of some other commit. Now run your application and check whether there is still a bug. If the bug is still there, then it must be between this commit and good commit</p>
<div class="highlight"><pre><span></span><code><span class="c1">#This means bug is between bad and this good commit</span>
git<span class="w"> </span>bisect<span class="w"> </span>good
</code></pre></div>
<p>Repeat the process until you find the bug. So using the bisect tool we can divide the history in half. This is how binary search also works.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Run this to get out of bisect state</span>
git<span class="w"> </span>bisect<span class="w"> </span>reset
</code></pre></div>
<h2 id="tagging">Tagging<a class="headerlink" href="#tagging" title="Permanent link">&para;</a></h2>
<p>Tagging is very useful if you are releasing your application version wise.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Tags the latest commit</span>
git<span class="w"> </span>tag<span class="w"> </span>v1.0


<span class="c1">#Tags that particular commit</span>
git<span class="w"> </span>tag<span class="w"> </span>v1.0<span class="w"> </span>hashofthatcommit
</code></pre></div>
<p>The beautiful thing about this is, you can also use it as a reference.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#If you want to checkout this version, you can easily do this</span>
git<span class="w"> </span>checkout<span class="w"> </span>v1.0
</code></pre></div>
<p>To see all the tags we have created</p>
<div class="highlight"><pre><span></span><code><span class="c1">#lists all tags</span>
git<span class="w"> </span>tag
</code></pre></div>
<p>All the above tags are lightweight tags. But if you want to create an annotated tag, you can use -a flag</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Creates a tag with a short message, tagger, date and time when the tag is created</span>
git<span class="w"> </span>tag<span class="w"> </span>-a<span class="w"> </span>v1.1<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Newer version&quot;</span>


<span class="c1">#To see the details of an annotated tag</span>
git<span class="w"> </span>show<span class="w"> </span>v1.1
</code></pre></div>
<p>To delete a tag</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>tag<span class="w"> </span>-d<span class="w"> </span>v1.1
</code></pre></div>
<h2 id="stashing">Stashing<a class="headerlink" href="#stashing" title="Permanent link">&para;</a></h2>
<p>It is one of the advanced concepts and is very useful. As I told you before, when we switch branches, git resets our working directory to the snapshot stored in the last commit in that branch. Suppose you have local changes in your working directory that you still need to commit to. These changes could get lost. In that situation, git does not allow us to switch branches. If you are in the middle of something and quickly want to switch branches and are still working on work and want to commit, you can stash them. Stashing something means storing them in a safe place.
We will save them in our git repository, but they are not part of the history.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># By default, new untracked files are not included in the stash, you should add them or stage them.</span>
git<span class="w"> </span>stash<span class="w"> </span>push<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;In the middle of implementing new routes&quot;</span>

<span class="c1"># But if you are not interested to stage them</span>
git<span class="w"> </span>stash<span class="w"> </span>push<span class="w"> </span>--all<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;New stash&quot;</span>

<span class="c1"># or, you can mix both flags</span>
git<span class="w"> </span>stash<span class="w"> </span>push<span class="w"> </span>-am<span class="w"> </span><span class="s2">&quot;New stash&quot;</span>
</code></pre></div>
<p>To view all the stashes</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Each stash has an unique identifier</span>
git<span class="w"> </span>stash<span class="w"> </span>list
</code></pre></div>
<p>After that you can switch branches, and do your work. When you want to work on these stashes again, you can first view them</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Where 1 is the sequence number</span>
git<span class="w"> </span>stash<span class="w"> </span>show<span class="w"> </span><span class="m">1</span>
</code></pre></div>
<p>To apply the stashes</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>stash<span class="w"> </span>apply<span class="w"> </span><span class="m">1</span>
</code></pre></div>
<p>Once we applied stash we should remove the stash</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Drops the stash 1</span>
git<span class="w"> </span>stash<span class="w"> </span>drop<span class="w"> </span><span class="m">1</span>


<span class="c1">#If you want to remove all the stashes</span>
git<span class="w"> </span>stash<span class="w"> </span>clear
</code></pre></div>
<h2 id="worktrees">Worktrees<a class="headerlink" href="#worktrees" title="Permanent link">&para;</a></h2>
<p>Git worktrees allow you to have multiple working directories attached to the same Git repository. This feature is useful when you want to work on two different branches simultaneously without having to switch back and forth between them in a single working directory.</p>
<p>Here's a basic overview of how Git worktrees work:</p>
<ol>
<li>
<p>Main Working Directory: When you clone a Git repository, you create its main working directory. This is where you'll typically do most of your work.</p>
</li>
<li>
<p>Additional Worktrees: You can add new worktrees to your repository. Each worktree is linked to a different branch. This allows you to work on multiple branches at the same time, with each branch checked out in its own worktree.</p>
</li>
<li>
<p>Isolated Changes: Changes made in one worktree won't affect the others. This means you can work on different branches simultaneously without worrying about conflicts between them.</p>
</li>
</ol>
<h3 id="common_commands_for_worktrees">Common Commands for Worktrees<a class="headerlink" href="#common_commands_for_worktrees" title="Permanent link">&para;</a></h3>
<ol>
<li>Creating a New Worktree: To add a new worktree, you use the git worktree add <path> <branch> command. This creates a new directory at <path> where the <branch> is checked out.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">#Creates a new worktree at the path and checks out the branch</span>
git<span class="w"> </span>worktree<span class="w"> </span>add<span class="w"> </span>&lt;path&gt;<span class="w"> </span>&lt;branch&gt;
</code></pre></div>
<ol>
<li>Listing Worktrees: You can see a list of all the worktrees associated with your repository using the git worktree list command.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">#Lists all the worktrees</span>
git<span class="w"> </span>worktree<span class="w"> </span>list
</code></pre></div>
<ol>
<li>Removing a Worktree: To remove a worktree, you use the git worktree remove <path> command. This deletes the worktree and unlinks it from the repository.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">#Removes the worktree</span>
git<span class="w"> </span>worktree<span class="w"> </span>remove<span class="w"> </span>&lt;path&gt;
</code></pre></div>
<h3 id="advantages_of_using_worktrees">Advantages of Using Worktrees<a class="headerlink" href="#advantages_of_using_worktrees" title="Permanent link">&para;</a></h3>
<ol>
<li>Simultaneous Work on Multiple Branches: You can work on multiple features or bug fixes at the same time without having to commit or stash your changes to switch branches.</li>
<li>Clean Separation of Work: Each worktree has its own working directory, so there's no chance of mixing up changes from different branches.</li>
<li>Testing and Continuous Integration: Worktrees can be useful for testing changes in different branches without disrupting your main development workflow.</li>
</ol>
<p>In summary, Git worktrees provide a powerful way to manage parallel lines of development within the same repository, making it easier to multitask and separate different tasks cleanly.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../The90%25Stuff/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../The90%25Stuff/" class="btn btn-xs btn-link">
        The 90% Stuff
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href=".." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href=".." class="btn btn-xs btn-link">
        Home
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="None">Windmill Dark</a> theme by None (noraj).</p>
</footer>

</body>
</html>